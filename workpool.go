package coutil

import (
	"sync"
)

// WorkPool processes a slice of input items using a limited number of goroutines. The order in which output items are sent to the result processor is not guaranteed.
// [workerCount] is the number of goroutines that will work concurrently on the input items.
// [workItems] is a slice containing the input items that will be worked on.
// [operation] is a function that will execute within a goroutine and perform an operation on an input item and return an output item.
// [resultProcessor] is a function that executes on the calling thread and processes each output item generated by the work pool.
func WorkPool[InputItem any, OutputItem any](workerCount int, inputItems []InputItem, operation func(InputItem) OutputItem, resultProcessor func(OutputItem)) {
	// A channel to send work items to the workers
	inputChannel := make(chan InputItem)
	// A channel to receive results from the workers
	outputChannel := make(chan OutputItem)

	// Start a goroutine that sends work items to the work channel
	go func() {
		for _, input := range inputItems {
			inputChannel <- input
		}
		close(inputChannel)
	}()

	// WaitGroup to wait for all workers to finish
	var wg sync.WaitGroup
	wg.Add(workerCount)

	// Start workers that read from the work channel and write to the results channel
	for range workerCount {
		go func() {
			defer wg.Done()
			for input := range inputChannel {
				outputChannel <- operation(input)
			}
		}()
	}

	// Start a goroutine that waits for all the workers to finish and then closes the results channel
	go func() {
		wg.Wait()
		close(outputChannel)
	}()

	// Process the results as they arrive until the channel closes
	for output := range outputChannel {
		resultProcessor(output)
	}
}
